# 代码规范文档

## 1. 概述

本文档旨在规范联通运营商后台管理系统项目的代码编写风格，提高代码可读性、可维护性和团队协作效率。本规范适用于项目中的所有前端和后端代码。

## 2. 前端代码规范

### 2.1 TypeScript代码规范

#### 2.1.1 命名规范
- **变量和函数**：使用小驼峰命名法（camelCase）
  ```typescript
  const userName = 'admin';
  const getUserInfo = () => {};
  ```
- **常量**：使用大写字母和下划线（UPPER_SNAKE_CASE）
  ```typescript
  const API_BASE_URL = 'https://api.example.com';
  const MAX_PAGE_SIZE = 100;
  ```
- **类和接口**：使用大驼峰命名法（PascalCase）
  ```typescript
  class UserService {}
  interface UserInfo {}
  ```
- **类型别名**：使用大驼峰命名法（PascalCase）
  ```typescript
  type UserStatus = 'active' | 'inactive';
  ```
- **枚举**：使用大驼峰命名法（PascalCase）
  ```typescript
  enum UserRole {
    Admin = 'admin',
    User = 'user',
  }
  ```

#### 2.1.2 变量声明
- 优先使用 `const`，只有在需要重新赋值时使用 `let`
- 避免使用 `var`
- 变量声明应尽量靠近使用位置
  ```typescript
  // 好的示例
  const fetchData = async () => {
    const response = await api.get('/users');
    const users = response.data;
    return users;
  };
  
  // 不好的示例
  var data;
  let result;
  data = await api.get('/users');
  result = data.data;
  ```

#### 2.1.3 函数规范
- 函数名应清晰表达其功能
- 函数参数不宜过多（建议不超过5个），超过时使用对象参数
- 函数应保持单一职责原则
- 使用箭头函数，除非需要使用 `this` 上下文
  ```typescript
  // 好的示例
  const calculateTotal = (price: number, quantity: number): number => {
    return price * quantity;
  };
  
  const createUser = async (userData: CreateUserRequest): Promise<UserResponse> => {
    const response = await userApi.create(userData);
    return response.data;
  };
  
  // 不好的示例
  function d(p: number, q: number, t: number, d: number, s: number, r: number) {
    return (p * q + t * d) / s + r;
  }
  ```

#### 2.1.4 类型定义
- 为所有变量、函数参数和返回值明确指定类型
- 使用接口定义对象结构
- 使用联合类型和泛型提高代码复用性
  ```typescript
  // 好的示例
  interface User {
    id: number;
    name: string;
    email: string;
    status: UserStatus;
  }
  
  type ApiResponse<T> = {
    code: number;
    message: string;
    data: T;
  };
  
  const getUser = async (id: number): Promise<ApiResponse<User>> => {
    const response = await userApi.getById(id);
    return response.data;
  };
  
  // 不好的示例
  let user: any;
  function getData(id) {
    return fetch('/users/' + id);
  }
  ```

#### 2.1.5 异步处理
- 使用 `async/await` 处理异步操作，避免回调地狱
- 使用 `try/catch` 处理错误
- 合理使用 `Promise.all` 处理并行异步操作
  ```typescript
  // 好的示例
  const fetchUserData = async (userId: number): Promise<UserWithPosts> => {
    try {
      const [user, posts] = await Promise.all([
        userApi.getById(userId),
        postApi.getByUserId(userId),
      ]);
      
      return {
        user,
        posts,
      };
    } catch (error) {
      console.error('获取用户数据失败:', error);
      throw error;
    }
  };
  
  // 不好的示例
  function fetchUserData(userId, callback) {
    userApi.getById(userId, (user) => {
      postApi.getByUserId(userId, (posts) => {
        callback({
          user,
          posts,
        });
      });
    });
  }
  ```

### 2.2 Vue组件规范

#### 2.2.1 组件命名
- 组件文件名使用PascalCase，如 `UserList.vue`
- 组件在模板中使用PascalCase，如 `<UserList />`
- 组件名应具有描述性，避免缩写
  ```vue
  <!-- 好的示例 -->
  <template>
    <UserList />
  </template>
  
  <script setup lang="ts">
  import UserList from '@/components/UserList.vue';
  </script>
  
  <!-- 不好的示例 -->
  <template>
    <usr-lst />
  </template>
  
  <script>
  import usrLst from './c/usr_lst.vue';
  </script>
  ```

#### 2.2.2 组件结构
- 使用 `<script setup>` 语法糖
- 组件内容按以下顺序组织：
  1. `<template>` - 模板
  2. `<script setup lang="ts">` - 脚本
  3. `<style scoped>` - 样式
- 在 `<script setup>` 中按以下顺序组织代码：
  1. 导入语句
  2. Props 定义
  3. Emits 定义
  4. 响应式数据
  5. 计算属性
  6. 方法
  7. 生命周期钩子
  ```vue
  <!-- 好的示例 -->
  <template>
    <div class="user-card">
      <h2>{{ user.name }}</h2>
      <p>{{ user.email }}</p>
      <button @click="editUser">编辑</button>
    </div>
  </template>
  
  <script setup lang="ts">
  import { ref, computed } from 'vue';
  import type { User } from '@/types/user';
  
  // Props
  interface Props {
    userId: number;
  }
  
  const props = defineProps<Props>();
  
  // Emits
  const emit = defineEmits<{
    edit: [user: User];
  }>();
  
  // 响应式数据
  const user = ref<User | null>(null);
  const loading = ref(false);
  
  // 计算属性
  const userDisplayName = computed(() => {
    return user.value ? `${user.value.name} (${user.value.email})` : '未知用户';
  });
  
  // 方法
  const fetchUser = async () => {
    loading.value = true;
    try {
      user.value = await userApi.getById(props.userId);
    } catch (error) {
      console.error('获取用户信息失败:', error);
    } finally {
      loading.value = false;
    }
  };
  
  const editUser = () => {
    if (user.value) {
      emit('edit', user.value);
    }
  };
  
  // 生命周期
  onMounted(() => {
    fetchUser();
  });
  </script>
  
  <style scoped>
  .user-card {
    padding: 16px;
    border: 1px solid #eee;
    border-radius: 4px;
  }
  </style>
  ```

#### 2.2.3 模板规范
- 使用缩进保持代码结构清晰
- 属性值使用双引号
- 多个属性时合理换行
- 避免复杂的表达式，使用计算属性或方法
  ```vue
  <!-- 好的示例 -->
  <template>
    <div class="user-list">
      <div
        v-for="user in filteredUsers"
        :key="user.id"
        class="user-item"
        :class="{ 'is-active': user.isActive }"
        @click="selectUser(user)"
      >
        <h3>{{ user.name }}</h3>
        <p>{{ user.email }}</p>
      </div>
    </div>
  </template>
  
  <!-- 不好的示例 -->
  <template>
    <div class='user-list'>
      <div v-for='user in users.filter(u => u.status === "active" && u.role === "admin")' :key='user.id' class='user-item' @click='selectUser(user)'>
        <h3>{{user.name}}</h3>
        <p>{{user.email}}</p>
      </div>
    </div>
  </template>
  ```

### 2.3 CSS/SCSS规范

#### 2.3.1 命名规范
- 使用BEM（Block Element Modifier）命名规范
- 类名使用小写字母和连字符
- 避免使用ID选择器
  ```scss
  // 好的示例
  .user-card {
    padding: 16px;
    
    &__header {
      display: flex;
      justify-content: space-between;
    }
    
    &__title {
      font-size: 18px;
      font-weight: bold;
    }
    
    &__content {
      margin-top: 12px;
    }
    
    &--highlighted {
      border: 1px solid #409eff;
    }
  }
  
  // 不好的示例
  .userCard {
    padding: 16px;
  }
  
  .userCardHeader {
    display: flex;
  }
  
  #userTitle {
    font-size: 18px;
  }
  ```

#### 2.3.2 样式组织
- 按照以下顺序组织样式：
  1. 定位属性（position, top, right, z-index, display, float等）
  2. 大小（width, height, padding, margin）
  3. 文字系列（font, line-height, letter-spacing, color, text-align等）
  4. 背景（background, border等）
  5. 其他（animation, transition等）
- 使用SCSS变量定义颜色、尺寸等常量
  ```scss
  // 好的示例
  $primary-color: #409eff;
  $success-color: #67c23a;
  $warning-color: #e6a23c;
  $danger-color: #f56c6c;
  
  $border-radius-base: 4px;
  $border-radius-small: 2px;
  $border-radius-large: 8px;
  
  $spacing-small: 8px;
  $spacing-base: 16px;
  $spacing-large: 24px;
  
  .button {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    height: 32px;
    padding: 0 $spacing-base;
    border: 1px solid $primary-color;
    border-radius: $border-radius-base;
    font-size: 14px;
    color: $primary-color;
    background-color: #fff;
    cursor: pointer;
    transition: all 0.3s;
    
    &:hover {
      color: #fff;
      background-color: $primary-color;
    }
    
    &--large {
      height: 40px;
      padding: 0 $spacing-large;
      font-size: 16px;
    }
    
    &--small {
      height: 24px;
      padding: 0 $spacing-small;
      font-size: 12px;
    }
  }
  
  // 不好的示例
  .button {
    color: #409eff;
    background-color: #fff;
    border: 1px solid #409eff;
    border-radius: 4px;
    padding: 0 16px;
    height: 32px;
    display: inline-flex;
    font-size: 14px;
    cursor: pointer;
    transition: all 0.3s;
    align-items: center;
    justify-content: center;
  }
  ```

## 3. 后端代码规范

### 3.1 Java代码规范

#### 3.1.1 命名规范
- **类名**：使用大驼峰命名法（PascalCase），名词形式
  ```java
  // 好的示例
  public class UserService {}
  public class UserController {}
  public class UserRepository {}
  
  // 不好的示例
  public class userservice {}
  public class user_controller {}
  public class getUser {}
  ```
- **方法名**：使用小驼峰命名法（camelCase），动词形式
  ```java
  // 好的示例
  public User getUserById(Long id) {}
  public List<User> getAllUsers() {}
  public void createUser(User user) {}
  
  // 不好的示例
  public User Get_User_By_Id(Long id) {}
  public List<User> getallusers() {}
  public void Create_User(User user) {}
  ```
- **变量名**：使用小驼峰命名法（camelCase）
  ```java
  // 好的示例
  private String userName;
  private List<User> userList;
  private final int maxPageSize = 100;
  
  // 不好的示例
  private String user_name;
  private List<User> UserList;
  private final int MAXPAGESIZE = 100;
  ```
- **常量**：使用大写字母和下划线（UPPER_SNAKE_CASE）
  ```java
  // 好的示例
  public static final String API_BASE_URL = "https://api.example.com";
  public static final int MAX_PAGE_SIZE = 100;
  
  // 不好的示例
  public static final String apiBaseUrl = "https://api.example.com";
  public static final int maxPageSize = 100;
  ```
- **包名**：使用小写字母，多个单词用点分隔
  ```java
  // 好的示例
  package com.unicom.controller;
  package com.unicom.service.impl;
  package com.unicom.repository;
  
  // 不好的示例
  package com.Unicom.Controller;
  package com.unicom.service_implementation;
  package com.unicom.Repository;
  ```

#### 3.1.2 代码格式
- 使用4个空格缩进，不使用Tab
- 大括号放在行末，不另起一行
- if、for、while等语句即使只有一行也要使用大括号
- 行长度不超过120个字符
- 操作符两边添加空格
  ```java
  // 好的示例
  public class UserService {
      private static final int MAX_PAGE_SIZE = 100;
      
      public User getUserById(Long id) {
          if (id == null || id <= 0) {
              throw new IllegalArgumentException("用户ID不能为空或小于等于0");
          }
          
          return userRepository.findById(id)
                  .orElseThrow(() -> new NotFoundException("用户不存在"));
      }
      
      public List<User> getUsersByStatus(UserStatus status, int page, int size) {
          if (page < 0) {
              page = 0;
          }
          
          if (size <= 0 || size > MAX_PAGE_SIZE) {
              size = MAX_PAGE_SIZE;
          }
          
          Pageable pageable = PageRequest.of(page, size);
          return userRepository.findByStatus(status, pageable);
      }
  }
  
  // 不好的示例
  public class UserService{
  private static final int MAX_PAGE_SIZE=100;
  public User getUserById(Long id){
  if(id==null||id<=0)
  throw new IllegalArgumentException("用户ID不能为空或小于等于0");
  return userRepository.findById(id).orElseThrow(()->new NotFoundException("用户不存在"));
  }
  }
  ```

#### 3.1.3 注释规范
- 类、接口、枚举等使用Javadoc注释
- 公共方法使用Javadoc注释，说明方法功能、参数、返回值和异常
- 复杂逻辑使用单行或多行注释
- 注释内容应准确、简洁、有意义
  ```java
  /**
   * 用户服务类，提供用户相关的业务逻辑处理
   * 
   * @author 开发者姓名
   * @since 1.0.0
   */
  @Service
  public class UserService {
      
      private final UserRepository userRepository;
      
      /**
       * 根据用户ID获取用户信息
       * 
       * @param id 用户ID，不能为空或小于等于0
       * @return 用户信息
       * @throws IllegalArgumentException 当用户ID为空或小于等于0时抛出
       * @throws NotFoundException 当用户不存在时抛出
       */
      public User getUserById(Long id) {
          // 参数校验
          if (id == null || id <= 0) {
              throw new IllegalArgumentException("用户ID不能为空或小于等于0");
          }
          
          // 查询用户信息
          return userRepository.findById(id)
                  .orElseThrow(() -> new NotFoundException("用户不存在"));
      }
  }
  ```

#### 3.1.4 异常处理
- 使用自定义异常类，避免直接使用Exception
- 异常信息应清晰、有意义
- 使用try-with-resources处理资源
- 记录异常日志，便于问题排查
  ```java
  // 好的示例
  @Service
  public class UserService {
      
      private static final Logger logger = LoggerFactory.getLogger(UserService.class);
      
      public void updateUserStatus(Long userId, UserStatus status) {
          try {
              User user = getUserById(userId);
              user.setStatus(status);
              userRepository.save(user);
              logger.info("用户状态更新成功，用户ID: {}, 新状态: {}", userId, status);
          } catch (NotFoundException e) {
              logger.error("更新用户状态失败，用户不存在，用户ID: {}", userId, e);
              throw e;
          } catch (Exception e) {
              logger.error("更新用户状态失败，用户ID: {}, 状态: {}", userId, status, e);
              throw new ServiceException("更新用户状态失败", e);
          }
      }
  }
  
  // 不好的示例
  @Service
  public class UserService {
      
      public void updateUserStatus(Long userId, UserStatus status) {
          try {
              User user = getUserById(userId);
              user.setStatus(status);
              userRepository.save(user);
          } catch (Exception e) {
              // 捕获所有异常，但不处理
              System.out.println("更新失败");
          }
      }
  }
  ```

### 3.2 Spring Boot代码规范

#### 3.2.1 控制器规范
- 使用RESTful风格的API设计
- 使用适当的HTTP方法（GET、POST、PUT、DELETE等）
- 使用`@RestController`注解
- 使用`@RequestMapping`及其变体注解定义路径
- 使用`@PathVariable`、`@RequestParam`、`@RequestBody`获取参数
- 使用`@Valid`进行参数校验
- 返回统一的响应格式
  ```java
  // 好的示例
  @RestController
  @RequestMapping("/api/v1/users")
  @Validated
  public class UserController {
      
      private final UserService userService;
      
      public UserController(UserService userService) {
          this.userService = userService;
      }
      
      /**
       * 根据ID获取用户信息
       */
      @GetMapping("/{id}")
      public ApiResponse<UserVO> getUserById(@PathVariable Long id) {
          User user = userService.getUserById(id);
          UserVO userVO = UserConverter.toVO(user);
          return ApiResponse.success(userVO);
      }
      
      /**
       * 创建用户
       */
      @PostMapping
      public ApiResponse<UserVO> createUser(@Valid @RequestBody CreateUserRequest request) {
          User user = userService.createUser(request);
          UserVO userVO = UserConverter.toVO(user);
          return ApiResponse.success(userVO);
      }
      
      /**
       * 更新用户信息
       */
      @PutMapping("/{id}")
      public ApiResponse<UserVO> updateUser(
              @PathVariable Long id, 
              @Valid @RequestBody UpdateUserRequest request) {
          User user = userService.updateUser(id, request);
          UserVO userVO = UserConverter.toVO(user);
          return ApiResponse.success(userVO);
      }
      
      /**
       * 删除用户
       */
      @DeleteMapping("/{id}")
      public ApiResponse<Void> deleteUser(@PathVariable Long id) {
          userService.deleteUser(id);
          return ApiResponse.success();
      }
  }
  
  // 不好的示例
  @RestController
  public class UserController {
      
      @GetMapping("/getUser")
      public String getUser(String id) {
          // 直接返回字符串，不使用统一响应格式
          return userService.getUserById(id).toString();
      }
      
      @PostMapping("/addUser")
      public void addUser(HttpServletRequest request) {
          // 直接从请求中获取参数，不使用DTO
          String name = request.getParameter("name");
          String email = request.getParameter("email");
          // ...
      }
  }
  ```

#### 3.2.2 服务层规范
- 使用`@Service`注解
- 使用接口和实现类分离
- 方法应具有事务性（`@Transactional`）
- 避免在服务层中直接访问数据库
- 处理业务逻辑和异常
  ```java
  // 好的示例
  public interface UserService {
      User getUserById(Long id);
      User createUser(CreateUserRequest request);
      User updateUser(Long id, UpdateUserRequest request);
      void deleteUser(Long id);
      Page<User> getUsers(UserQueryRequest request, Pageable pageable);
  }
  
  @Service
  @Transactional(readOnly = true)
  public class UserServiceImpl implements UserService {
      
      private final UserRepository userRepository;
      private final UserConverter userConverter;
      
      public UserServiceImpl(UserRepository userRepository, UserConverter userConverter) {
          this.userRepository = userRepository;
          this.userConverter = userConverter;
      }
      
      @Override
      public User getUserById(Long id) {
          return userRepository.findById(id)
                  .orElseThrow(() -> new NotFoundException("用户不存在"));
      }
      
      @Override
      @Transactional
      public User createUser(CreateUserRequest request) {
          // 检查用户名是否已存在
          if (userRepository.existsByUsername(request.getUsername())) {
              throw new BusinessException("用户名已存在");
          }
          
          // 检查邮箱是否已存在
          if (userRepository.existsByEmail(request.getEmail())) {
              throw new BusinessException("邮箱已存在");
          }
          
          User user = userConverter.toEntity(request);
          user.setStatus(UserStatus.ACTIVE);
          user.setCreatedAt(LocalDateTime.now());
          
          return userRepository.save(user);
      }
      
      // 其他方法...
  }
  
  // 不好的示例
  @Service
  public class UserService {
      
      @Autowired
      private UserRepository userRepository;
      
      public User getUserById(Long id) {
          return userRepository.findById(id).orElse(null);
      }
      
      public User createUser(CreateUserRequest request) {
          // 不检查用户名和邮箱是否已存在
          User user = new User();
          user.setUsername(request.getUsername());
          user.setEmail(request.getEmail());
          return userRepository.save(user);
      }
  }
  ```

#### 3.2.3 数据访问层规范
- 使用`@Repository`注解
- 继承`JpaRepository`或`MongoRepository`等
- 使用自定义方法命名约定
- 使用`@Query`注解定义复杂查询
- 使用`@Transactional`确保事务性
  ```java
  // 好的示例
  @Repository
  public interface UserRepository extends JpaRepository<User, Long> {
      
      /**
       * 根据用户名查找用户
       */
      Optional<User> findByUsername(String username);
      
      /**
       * 根据邮箱查找用户
       */
      Optional<User> findByEmail(String email);
      
      /**
       * 检查用户名是否存在
       */
      boolean existsByUsername(String username);
      
      /**
       * 检查邮箱是否存在
       */
      boolean existsByEmail(String email);
      
      /**
       * 根据状态分页查询用户
       */
      Page<User> findByStatus(UserStatus status, Pageable pageable);
      
      /**
       * 根据创建时间范围查询用户
       */
      @Query("SELECT u FROM User u WHERE u.createdAt BETWEEN :startDate AND :endDate")
      List<User> findByCreatedAtBetween(
              @Param("startDate") LocalDateTime startDate, 
              @Param("endDate") LocalDateTime endDate);
      
      /**
       * 统计各状态用户数量
       */
      @Query("SELECT u.status, COUNT(u) FROM User u GROUP BY u.status")
      List<Object[]> countByStatus();
  }
  
  // 不好的示例
  @Repository
  public interface UserRepository extends JpaRepository<User, Long> {
      
      // 使用原生SQL，不利用Spring Data JPA的方法命名约定
      @Query(value = "SELECT * FROM user WHERE username = ?1", nativeQuery = true)
      User findByUsername(String username);
      
      // 方法名不规范
      List<User> getAllActiveUsers();
      
      // 不使用分页
      List<User> findByStatus(UserStatus status);
  }
  ```

## 4. 数据库规范

### 4.1 表设计规范
- 表名使用小写字母和下划线（snake_case）
- 表名应具有描述性，使用单数形式
- 每个表应有主键，推荐使用自增ID
- 每个表应有创建时间、更新时间字段
- 使用逻辑删除，不物理删除数据
- 外键字段使用`_id`后缀
  ```sql
  -- 好的示例
  CREATE TABLE user (
      id BIGINT AUTO_INCREMENT PRIMARY KEY COMMENT '用户ID',
      username VARCHAR(50) NOT NULL UNIQUE COMMENT '用户名',
      email VARCHAR(100) NOT NULL UNIQUE COMMENT '邮箱',
      password VARCHAR(255) NOT NULL COMMENT '密码',
      status TINYINT NOT NULL DEFAULT 1 COMMENT '状态：1-正常，0-禁用',
      role_id BIGINT COMMENT '角色ID',
      created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
      updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
      deleted_at DATETIME COMMENT '删除时间',
      INDEX idx_username (username),
      INDEX idx_email (email),
      INDEX idx_status (status),
      INDEX idx_created_at (created_at),
      FOREIGN KEY (role_id) REFERENCES role(id)
  ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='用户表';
  
  -- 不好的示例
  CREATE TABLE Users (
      ID INT PRIMARY KEY,
      Name VARCHAR(50),
      Email VARCHAR(100),
      Password VARCHAR(255),
      RoleID INT,
      CreateTime DATETIME
  ) ENGINE=InnoDB;
  ```

### 4.2 字段设计规范
- 字段名使用小写字母和下划线（snake_case）
- 字段名应具有描述性
- 选择合适的数据类型和长度
- 字段应有注释说明
- 枚举字段使用注释说明各值含义
- 金额字段使用DECIMAL类型，避免使用FLOAT和DOUBLE
  ```sql
  -- 好的示例
  CREATE TABLE plan (
      id BIGINT AUTO_INCREMENT PRIMARY KEY COMMENT '套餐ID',
      name VARCHAR(100) NOT NULL COMMENT '套餐名称',
      price DECIMAL(10,2) NOT NULL COMMENT '套餐价格',
      data_flow INT NOT NULL COMMENT '流量(MB)',
      voice_minutes INT NOT NULL COMMENT '通话时长(分钟)',
      broadband_speed INT COMMENT '宽带速度(Mbps)',
      status TINYINT NOT NULL DEFAULT 1 COMMENT '状态：1-正常，0-禁用',
      created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
      updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
      deleted_at DATETIME COMMENT '删除时间',
      INDEX idx_name (name),
      INDEX idx_price (price),
      INDEX idx_status (status)
  ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='套餐表';
  
  -- 不好的示例
  CREATE TABLE plan (
      id INT PRIMARY KEY,
      pname VARCHAR(100),
      price FLOAT,
      data INT,
      voice INT,
      broadband INT,
      status INT,
      time DATETIME
  ) ENGINE=InnoDB;
  ```

## 5. 代码审查规范

### 5.1 审查流程
- 代码提交前进行自检
- 提交Pull Request进行代码审查
- 至少需要一人审查通过后才能合并
- 审查者应关注代码质量、逻辑正确性和安全性
- 审查意见应及时响应和修改

### 5.2 审查要点
- 代码是否符合项目编码规范
- 逻辑是否正确，是否存在潜在bug
- 性能是否有优化空间
- 安全性是否考虑周全
- 代码是否易于理解和维护
- 是否有足够的测试覆盖
- 注释是否清晰、准确

### 5.3 审查工具
- 使用GitLab/GitHub的Pull Request功能
- 使用SonarQube进行代码质量检查
- 使用ESLint、Checkstyle等静态代码分析工具
- 使用代码覆盖率工具检查测试覆盖率

## 6. 测试规范

### 6.1 测试分类
- 单元测试：测试单个方法或类的功能
- 集成测试：测试多个组件之间的协作
- 端到端测试：测试完整的业务流程
- 性能测试：测试系统性能指标

### 6.2 测试命名规范
- 测试类名：被测试类名 + Test
- 测试方法名：test + 方法名 + 场景
  ```java
  // 好的示例
  public class UserServiceTest {
      
      @Test
      public void testGetUserById_WhenUserExists_ShouldReturnUser() {
          // 测试用户存在时返回用户信息
      }
      
      @Test
      public void testGetUserById_WhenUserNotExists_ShouldThrowException() {
          // 测试用户不存在时抛出异常
      }
      
      @Test
      public void testCreateUser_WhenValidRequest_ShouldCreateUser() {
          // 测试有效请求时创建用户
      }
  }
  
  // 不好的示例
  public class UserServiceTest {
      
      @Test
      public void test1() {
          // 测试获取用户
      }
      
      @Test
      public void test2() {
          // 测试创建用户
      }
  }
  ```

### 6.3 测试覆盖率
- 单元测试覆盖率不低于80%
- 核心业务逻辑覆盖率不低于90%
- 测试应覆盖正常流程和异常情况

---

文档版本：V1.0  
创建日期：2023年11月15日  
最后更新：2023年11月15日  
创建人：架构师  
审核人：技术总监